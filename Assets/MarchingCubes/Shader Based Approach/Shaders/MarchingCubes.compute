#pragma kernel CSMain

#include "MarchingCubesTable.compute"

// Buffers
StructuredBuffer<float> densityMap;
RWStructuredBuffer<float3> vertices;
RWStructuredBuffer<int> triangles;
RWStructuredBuffer<int> vertexCounter;
RWStructuredBuffer<int> triangleCounter;

// Parameters
int gridSize;
float voxelSize;
float isoLevel;

// Helper function to get density value
float SampleDensity(uint3 pos)
{
    return densityMap[pos.x + gridSize * (pos.y + gridSize * pos.z)];
}

// Helper function to get corner positions for a voxel
uint3 GetVoxelCorner(uint3 basePos, int cornerIndex)
{
    uint3 cornerOffsets[8] = {
        uint3(0, 0, 0),
        uint3(1, 0, 0),
        uint3(0, 1, 0),
        uint3(1, 1, 0),
        uint3(0, 0, 1),
        uint3(1, 0, 1),
        uint3(0, 1, 1),
        uint3(1, 1, 1)
    };
    return basePos + cornerOffsets[cornerIndex];
}

// Helper function to get world position
float3 GetWorldPosition(uint3 pos)
{
    return (float3)(pos - uint3(gridSize/2, gridSize/2, gridSize/2)) * voxelSize;
}

// Helper function to interpolate between vertices
float3 InterpolateVerts(float3 v1, float3 v2, float d1, float d2)
{
    float t = (isoLevel - d1) / (d2 - d1);
    return v1 + t * (v2 - v1);
}

[numthreads(8,8,8)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Check if we're within bounds
    if (any(id >= uint3(gridSize-1, gridSize-1, gridSize-1))) return;

    // Get densities for current cube
    float cubeValues[8];
    float3 positions[8];
    
    // Sample all 8 corners of the cube
    for (int i = 0; i < 8; i++)
    {
        uint3 corner = GetVoxelCorner(id, i);
        cubeValues[i] = SampleDensity(corner);
        positions[i] = GetWorldPosition(corner);
    }

    // Calculate cube index
    int cubeIndex = 0;
    for (int i = 0; i < 8; i++)
    {
        if (cubeValues[i] < isoLevel)
        {
            cubeIndex |= 1 << i;
        }
    }

    // Early exit if cube is entirely inside or outside surface
    if (edgeTable[cubeIndex] == 0) return;

    // Find vertices where surface intersects edges
    float3 vertList[12];
    for (int i = 0; i < 12; i++)
    {
        if ((edgeTable[cubeIndex] & (1 << i)) != 0)
        {
            int v1 = cornerIndexAFromEdge[i];
            int v2 = cornerIndexBFromEdge[i];
            
            vertList[i] = InterpolateVerts(
                positions[v1],
                positions[v2],
                cubeValues[v1],
                cubeValues[v2]
            );
        }
    }

    // Create triangles
    int numTriangles = 0;
    for (int i = 0; triangulation[cubeIndex][i] != -1; i += 3)
    {
        // Get starting indices for vertices and triangles
        int vertexStart;
        InterlockedAdd(vertexCounter[0], 3, vertexStart);
        
        // Add three vertices
        for (int j = 0; j < 3; j++)
        {
            int edgeIndex = triangulation[cubeIndex][i + j];
            vertices[vertexStart + j] = vertList[edgeIndex];
        }
        
        // Add triangle indices
        int triStart;
        InterlockedAdd(triangleCounter[0], 3, triStart);
        for (int j = 0; j < 3; j++)
        {
            triangles[triStart + j] = vertexStart + j;
        }
    }
}